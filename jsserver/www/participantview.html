<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <title>Visual Encoding App</title>
    <script src="networkgenerator.js"></script>
    <script src="colorbrewer.js"></script>
    <script src="cytoscape.js"></script>
    <script src="d3.js"></script>
    <script src="jquery.js"></script>
    <script src="fcns.js"></script>
    <script src="cytoscape-cola.js"></script>
    <script src="datafiles.js"></script>
    <script src="reimg.js"></script>
    <style>
        /*#cy {*/
            /*width: 100%;*/
            /*height: 40%;*/
            /*position: absolute;*/
            /*top: 400px;*/
            /*left: 0px;*/
            /*display: none;*/
        /*}*/
        #cy {
            width: 100%;
            height: 100%;
            position: absolute;
            /*top: 500px;*/
            /*left: 0px;*/
            /*top: 0px;*/
            /*left: 600px;*/
            display: none;
            float: right;
        }
    </style>
</head>
<div id="rankTableSection">
    <input id="numEncodings" placeholder="Number of Encodings">
    <input id="numTasks" placeholder="Number of Dim*Tasks">
    <input id="numAssignments" placeholder="Number of Assignments">
    <input id="taskChoice" placeholder="Index of Task">
    <button id="updateTableDim" onclick="updateTableDimensions()">update table</button>
    <button id="randvalues" onclick="randomRanks()">generate random ranks</button>
    <button id="rankvalues" onclick="generateBaselineRank(taskNames[parseInt($('#taskChoice').val())])">load ranks</button>
    <button id="sendranktable" onclick="sendToR()">send table</button>
    <button id="saveimage" onclick="to_image()">Save as Image</button><br><br>
    <input id="numNodes" placeholder="Number of Nodes">
    <input id="numEdges" placeholder="Number of Edges">
    <button id="visualizeNetwork" onclick="plotNetwork('default')">visualize default</button>
    <button id="visualizeGeneMANIA_BRCA" onclick="plotNetwork('genemania_BRCA')">visualize BRCA</button>
    <button id="visualizeGeneMANIA_APP" onclick="plotNetwork('genemania_APP')">visualize APP</button>
    <button id="updateVisualizedNetwork" onclick="internalData()">Dyanmo!</button>
    <span id="time"></span>
</div>
<!--<div id="uploadGraphSection">-->
    <!--<div id="dvImportSegments" class="fileupload">-->
        <!--<fieldset>-->
            <!--<legend>Upload your Network File</legend>-->
            <!--<input type="file" name="File Upload" id="txtFileUpload" />-->
        <!--</fieldset>-->
    <!--</div>-->
<!--</div>-->
<div id="layoutButtonSection">
    <button id="layoutRand" onclick="newlayout('random')">Random</button>
    <button id="layoutCircle" onclick="newlayout('circle')">Circle</button>
    <button id="layoutCose" onclick="newlayout('cose')">Cose</button>
    <button id="layoutBf" onclick="newlayout('breadthfirst')">BF</button>
    <button id="layoutGrid" onclick="newlayout('grid')">Grid</button>
</div>
<div id="cy">
</div>
<image id="theimage"></image>
</body>
<script type="application/javascript">

//    var newtime;
//
//    function startTimer(duration, display) {
//        var timer = duration, minutes, seconds;
//        newtime = setInterval(function () {
//            minutes = parseInt(timer / 60, 10)
//            seconds = parseInt(timer % 60, 10);
//
//            minutes = minutes < 10 ? "0" + minutes : minutes;
//            seconds = seconds < 10 ? "0" + seconds : seconds;
//
//            display.textContent = minutes + ":" + seconds;
//
//            if (--timer < 0) {
//                clearInterval(newtime);
//                wholeWorkflow();
//            }
//        }, 1000);
//    }

    Array.prototype.getUnique = function(){
        var u = {}, a = [];
        for(var i = 0, l = this.length; i < l; ++i){
            if(u.hasOwnProperty(this[i])) {
                continue;
            }
            a.push(this[i]);
            u[this[i]] = 1;
        }
        return a;
    };

    function to_image(){
//        var base64img = cy.png();
//        var url = base64img.src.replace(/^data:image\/[^;]/, 'data:application/octet-stream');
//        window.open(url);
        return window.open(cy.png().replace(/^data:image\/[^;]/, 'data:application/octet-stream'));
    }

    var body = d3.select('body');

    var numberOfEncodings = 5;
    var numberOfTasks = 5;
    var numberOfAssignments;
    var cy;
    var tasks = [];
    var encodings;
    var Robj;
    var taskWithDims = [];

//    var dims = ['dim1', 'dim2', 'dim3'];
    var dims = ['dim1', 'dim2', 'dim2-2'];
//    var dims = ['dim1'];
    var encs = ['node color (seq)',
        'node color (div)',
        'node color (cat)',
        'node shape (cat)',
        'node border (quant)',
        'node border (bin)',
        'node border (cat)', //patterns
        'node size (quant)',
        'node size (bin)',
        'edge width (quant)',
        'edge width (bin)',
        'edge color (seq)',
        'edge color (div)',
        'edge color (cat)',
        'edge pattern (cat)',
        'edge arrow (cat)'
    ];


    //only used in editStyle()?
    var enclookup = {'row1': {'type':'node','attribute':'background-color'}, //can define function to use here?
                    'row2': {'type':'node','attribute':'border-width'},
                    'row3': {'type':'edge','attribute':'width'},
                    'row4': {'type':'edge','attribute':'line-color'},
                    'row5': {'type':'edge','attribute':'line-style'},
                    'row6': {'type':'edge','attribute':'target-arrow-shape'}
    };
    // Nodes
    // background-blacken
    // background-opacity
    // border-width
    // border-style
    // border-color
    // border-opacity
    //
    // Edges
    // curve-style
    // segment-distances (for edges made of several straight lines)
    // <pos>-arrow-color
    // <pos>-arrow-shape
    // <pos>-arrow-fill
    //
    // Labels
    // label
    // source-label
    // target-label (and also font styling among other things)

    // I need to clarify usage between manifest and cytoscape data, and also clarify how type and usage are different
    // and used. In a nutshell, it doesn't look like the highlightimproperencodings function is working the way I
    // want, and I think it's due to the way I've defined and used some of these terms
//    var manifest = {
//        'dim1 task1' : {type: 'numeric', usage: ['numeric'], name: 'p-val', element: 'node', ind:0 },
//        'dim2 task1' : {type: 'numeric', usage: ['numeric'], name: 'coexpression', element: 'edge', ind:1 },
//        'dim3 task1' : {type: 'categorical', usage: ['categorical'], name: 'pathway', element: 'node', ind:2 },
//        'dim1 task2' : {type: 'numeric', usage: ['numeric'], name: 'p-val', element: 'node', ind:3 },
//        'dim2 task2' : {type: 'numeric', usage: ['numeric'], name: 'coexpression', element: 'edge', ind:4 },
//        'dim3 task2' : {type: 'categorical', usage: ['categorical'], name: 'pathway', element: 'node', ind:5 }
//    };

    var manifest = {
        'dim1 task1' : {type: 'numeric', usage: ['numeric'], name: 'weight', element: 'edge', ind:0 },
//        'dim2 task1' : {type: 'categorical', usage: ['categorical'], name: 'group', element: 'edge', ind:1 },
        'dim2 task1' : {type: 'numeric', usage: ['numeric'], name: 'area', element: 'node', ind:1 },
        'dim2-2 task1' : {type: 'numeric', usage: ['numeric'], name: 'area', element: 'node', ind:2 }
//        'dim1 task2' : {type: 'numeric', usage: ['numeric'], name: 'weight', element: 'edge', ind:2 },
//        'dim2 task2' : {type: 'categorical', usage: ['categorical'], name: 'group', element: 'edge', ind:3 }
    };

    function internalData() {
        try {
            cy.style(reviseViz());
            //make sure that the node width is symmetrical to height
            cy.nodes().style('width', function(n){return n.height();});
        } catch(err) {
            console.log(err);
            cy.style(reviseViz().reverse());
            //make sure that the node width is symmetrical to height
            cy.nodes().style('width', function(n){return n.height();});
        }
    }

    function dataHierarchy(input) {
        if (input === 'numeric') {
            return ['numeric','categorical'];
        }
        else if (input === 'categorical') {
            return ['categorical'];
        }
        else {
            return ['error'];
        }
    }


        var allowedEncodings = {
            'node color (seq)': ['numeric'],
            'node color (div)': ['numeric'],
            'node color (cat)': ['categorical'], // seems to work better when set to numeric..
            'node shape (cat)': ['categorical'],
            'node border (quant)': ['numeric'],
            'node border (bin)': ['numeric'],
            'node border (cat)': ['categorical'], //patterns
            'node size (quant)' : ['numeric'],
            'node size (bin)' : ['numeric'],
            'edge width (quant)': ['numeric'],
            'edge width (bin)': ['numeric'],
            'edge color (seq)': ['numeric'],
            'edge color (div)': ['numeric'],
            'edge color (cat)': ['categorical'],
            'edge pattern (cat)': ['categorical'],
            'edge arrow (cat)': ['categorical']
        };


        var encodingRenderFunctions = {
            'node color (seq)':    {func:nodecolor_seq, intype:['numeric'], outtype:['categorical'], element:'node', ind:0},
            'node color (div)':    {func:nodecolor_div, intype:['numeric'], outtype:['categorical'], element:'node', ind:1},
            'node color (cat)':    {func:nodecolor_cat, intype:['numeric', 'categorical'], outtype:['categorical'], element:'node', ind:2},
            'node shape (cat)':    {func:nodeshape_cat, intype:['numeric', 'categorical'], outtype:['categorical'], element:'node', ind:3},
            'node border (quant)': {func:nodeborder_quant,intype:['numeric'], outtype:['numeric'], element:'node', ind:4},
            'node border (bin)':   {func:nodeborder_bin,intype:['numeric'], outtype:['categorical'], element:'node', ind:5},
            'node border (cat)':   {func:nodeborder_cat,intype:['numeric', 'categorical'], outtype:['categorical'], element:'node', ind:6},
            'node size (quant)': {func:nodesize_quant, intype:['numeric'], outtype:['numeric'], element:'node', ind:7},
            'node size (bin)':   {func:nodesize_bin, intype:['numeric'], outtype:['categorical'], element:'node', ind:8},
            'edge width (quant)':  {func:edgewidth_quant,intype:['numeric'], outtype:['numeric'], element:'edge', ind:9},
            'edge width (bin)':    {func:edgewidth_bin,intype:['numeric'], outtype:['categorical'], element:'edge', ind:10},
            'edge color (seq)':    {func:edgecolor_seq,intype:['numeric'], outtype:['categorical'], element:'edge', ind:11},
            'edge color (div)':    {func:edgecolor_div,intype:['numeric'], outtype:['categorical'], element:'edge', ind:12},
            'edge color (cat)':    {func:edgecolor_cat,intype:['numeric', 'categorical'], outtype:['categorical'], element:'edge', ind:13},
            'edge pattern (cat)':  {func:edgepattern_cat,intype:['numeric', 'categorical'], outtype:['categorical'], element:'edge', ind:14},
            'edge arrow (cat)':    {func:edgearrow_cat, intype:['numeric', 'categorical'], outtype:['categorical'], element:'edge', ind:15}
        };


        function highlightImproperEncodings() {
            //allowedEncodings['edge pattern'].indexOf(manifest["dim1 task 1"].usage) === -1 then improper
            //d3.selectAll('.rankedcell').attr('bgcolor', null);
            var encodingsWithNamesReplaced = [];
            for (var i = 1; i < encodings.length + 1; i++) {
                encodingsWithNamesReplaced.push(d3.selectAll('.enc' + i).text());
            }

            console.log(encodingsWithNamesReplaced);

            for (var t = 0; t < tasks.length; t++) {
                for (var e = 0; e < encodingsWithNamesReplaced.length; e++) {
                    if (Object.keys(allowedEncodings).indexOf(encodingsWithNamesReplaced[e]) !== -1) {
                        console.log([  t, tasks[t], e, encodingsWithNamesReplaced[e], manifest[tasks[t]].type, encodingRenderFunctions[encodingsWithNamesReplaced[e]].intype  ]);
                        // invalidate cells with conflicting data types
                        if (encodingRenderFunctions[encodingsWithNamesReplaced[e]].intype.indexOf(manifest[tasks[t]].type) === -1) {
                            d3.selectAll('.col' + (t + 1))
                                    .filter('.row' + (e + 1))
                                    .attr('bgcolor', 'gray')
                                    .text('0');
                        }
                        // ensure node dims not assigned to edge encodings, and visa-versa
                        if (encodingRenderFunctions[encodingsWithNamesReplaced[e]].element !== manifest[tasks[t]].element) {
                            d3.selectAll('.col' + (t + 1))
                                    .filter('.row' + (e + 1))
                                    .attr('bgcolor', 'gray')
                                    .text('0');
                        }
                    }
                }
            }
        }

        function updateTableDimensions() {
            numberOfEncodings = parseInt($("#numEncodings").val()) || encs.length;
            numberOfTasks = parseInt($("#numTasks").val()) || 1;
//        numberOfEncodings = parseInt(d3.select('#numEncodings')[0][0].value);
//        numberOfTasks = parseInt(d3.select('#numTasks')[0][0].value);
            console.log(numberOfEncodings);
            console.log(numberOfTasks);
            createTable(numberOfEncodings, numberOfTasks);
            for (var i = 0; i < encs.length; i++) {
                d3.select('.enc' + (i + 1)).text(encs[i]);
            }
        }

        function createTable(numberOfEncodings, numberOfTasks) {
            $('#rankTable').remove();
            tasks = [];
//        tasks = makeTasks(numberOfTasks);
            encodings = makeEncodings(numberOfEncodings);
            for (var e = 0; e < makeTasks(numberOfTasks).length; e++) {
                for (var d = 0; d < dims.length; d++) {
                    tasks.push(dims[d] + ' ' + makeTasks(numberOfTasks)[e]);
                }
            }
            console.log(encodings);
            console.log(tasks);
            var tabl = makeTable(encodings.length, tasks.length);
        }


        function makeTable(nr, nc) {
            var table = body.append("table")
                    .attr("id", "rankTable");
            var trData = [];

            d3.range(0, nr + 1).forEach(function (r) {
                var tr = table.append("tr");
                var tdData = [];
                d3.range(0, nc + 1).forEach(function (c) {
                    var td = tr.append("td")
                            .attr('contenteditable', 'true')
                            .text(function () {
                                if (r === 0) {
                                    return tasks[c - 1];
                                }
                                if (c === 0) {
                                    return encodings[r - 1];
                                }
                                return "(" + r + "," + c + ")";
                            })
                            .attr("id", function () {
                                if (r === 0) {
                                    return tasks[c - 1];
                                }
                                if (c === 0) {
                                    return encodings[r - 1];
                                }
                                return "cell_row" + r + "_col" + c;
                            })
                            .attr("class", function () {
                                if (r === 0) {
                                    return tasks[c - 1];
                                }
                                if (c === 0) {
                                    return encodings[r - 1];
                                }
                                return "rankedcell row" + r + " col" + c;
                            });
                    ;
                    tdData.push(td);
                });
                trData.push(tr);
            });
            return (trData);
        }

        function randomRanks() {
            d3.selectAll('.rankedcell').attr('bgcolor', null);
            for (var i = 1; i < tasks.length + 1; i++) {
                console.log(numberOfEncodings);
//                var ranks = generateArrayofBinaryValues(numberOfEncodings);
                var ranks = generateArrayofValues(numberOfEncodings);
                console.log(ranks);
                d3.selectAll(".col" + i)
                        .data(ranks)
                        .text(function (d) {
                            return d;
                        });
            }

            return 0;

            function generateArrayofBinaryValues(nrows) {
                var arr = [];
                d3.range(1, nrows + 1).forEach(function (k) {
                    arr.push(getRandomIntInclusive(0, 1));
                });
                return shuffle(arr);
            }


            function generateArrayofValues(nrows) {
                var arr = [];
                d3.range(1, nrows + 1).forEach(function (k) {
                    arr.push(getRandomIntInclusive(1, nrows));
                });
                return shuffle(arr);
            }

            function getRandomIntInclusive(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            function shuffle(array) {
                var currentIndex = array.length, temporaryValue, randomIndex;

                // While there remain elements to shuffle...
                while (0 !== currentIndex) {

                    // Pick a remaining element...
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex -= 1;

                    // And swap it with the current element.
                    temporaryValue = array[currentIndex];
                    array[currentIndex] = array[randomIndex];
                    array[randomIndex] = temporaryValue;
                }

                return array;
            }

        }

        function generateBaselineRank(taskname) {
            var taskItem = taskname || 'Task_Topology_Find_Clusters';
            var baselineranksdata = {};
            baselineValues.forEach(function(b){
                if (Object.keys(baselineMappings).indexOf(b.Encoding) !== -1){
                    baselineMappings[b.Encoding].forEach(function(enc){
                        console.log([enc, +b[taskItem]])
                        baselineranksdata[enc] = +b[taskItem];
                    })
                }
            });
            var encods = Object.keys(allowedEncodings);
            for (var i = 0; i < encods.length; i++) {
                d3.selectAll('.row'+(i+1)).text(function(){
                    return baselineranksdata[encods[i]] || 0;
                }).attr('bgcolor', null);
            }
            console.log("TASK AT HAND: "+ taskname);
        }

        function sendToR() {
            d3.selectAll('.rankedcell').attr('bgcolor', null);
            highlightImproperEncodings();
            var jsontable = rankTableToJSON();
            var numAssign = getNumberOfAssignments();
            console.log({table:jsontable, toAssign:numAssign});
            var tosend= {table:jsontable, toAssign:numAssign};


            return $.ajax({
                type: 'POST',
                url: 'lp',
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: JSON.stringify(tosend),
                success: function (data) {
                    console.log(data);
                    Robj = data;
                    highlightAssignedCells();
                    return data;
                }
            });
        }

        function uploadUserNetwork() {
            // this function needs work before it will run
            var file = $.get('#txtFileUpload');


            return $.ajax({
                type: 'POST',
                url: 'convert',
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: JSON.stringify(file),
                success: function (data) {
                    console.log(data);
                    return data;
                }
            });
        }


        function rankTableToJSON() {
            return $('table#rankTable tr').get().map(function (row) {
                return $(row).find('td').get().map(function (cell) {
                    return $(cell).html();
                });
            });
        }

        function makeTasks(amount) {
            return d3.range(1, amount + 1).map(function (a) {
                return "task" + a;
            });
        }

        function makeEncodings(amount) {
            return d3.range(1, amount + 1).map(function (a) {
                return "enc" + a;
            });
        }

        function highlightAssignedCells() {
//        d3.selectAll('.rankedcell').attr('bgcolor', null);
            var assignments = Robj;
            var numcols = Object.keys(Robj).length;
            console.log(numcols);
            for (var i = 0; i < numcols; i++) {
//            var row = assignments[Object.keys(Robj)[i]].indexOf(1);
                var row = assignments[Object.keys(Robj)[i]].map(function (d, i) {
                    if (d === 1) {
                        return i;
                    }
                }).filter(function (d) {
                    return d !== undefined
                });
                for (var k = 0; k < row.length; k++) {
                    var cellAssignment = d3.selectAll('.col' + (i + 1))
                            .filter('.row' + (row[k] + 1))
                            .attr('bgcolor', "#F3F315");
                }
            }
            return 0;
        }

        function getNumberOfAssignments() {
            if (isNaN(parseInt($("#numAssignments").val()))) {
                numberOfAssignments = d3.min([tasks.length, encodings.length]);
                return numberOfAssignments;
            }
            else {
                numberOfAssignments = parseInt($("#numAssignments").val());
                return numberOfAssignments;
            }
        }

        function plotNetwork(desireddata) {
            var cyCanvas = d3.selectAll('#cy')
                    .style('display', 'inline');

            var options = {
                name: 'random',
                fit: true, // whether to fit to viewport
                padding: 30, // fit padding
                boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
                animate: false, // whether to transition the node positions
                animationDuration: 500, // duration of animation in ms if enabled
                animationEasing: undefined, // easing of animation if enabled
                ready: undefined, // callback on layoutready
                stop: undefined, // callback on layoutstop
                minZoom: 1e-50,
                maxZoom: 1e50,
                zoomingEnabled: true,
                userZoomingEnabled: true,
                panningEnabled: true,
                userPanningEnabled: true,
                boxSelectionEnabled: false,
                selectionType: 'additive',
                touchTapThreshold: 8,
                desktopTapThreshold: 4,
                autolock: false,
                autoungrabify: false,
                autounselectify: false
            };

            if (desireddata === 'genemania_BRCA') {
                options.name = 'cose';
                cy = cytoscape({
                    container: document.getElementById('cy'),
                    elements: genemania_BRCA,
                    style: editStyle(generateStyle(), whichHighlight())
//                    selectionType: 'additive'
                });

                cy.on('select', 'node,edge', function(ev) {
                    console.log(ev);
                    var selectedElement = ev.cyTarget;
                    console.log(["CLICKERED", selectedElement.data()]);

                    var selecnodeattrs = thing.map(function(n){ if(n.type==="node"){ return n.style; } }).filter(function(n){ return n != undefined }).getUnique();
                    var selecedgeattrs = thing.map(function(n){ if(n.type==="edge"){ return n.style; } }).filter(function(n){ return n != undefined }).getUnique();
                    var tempdat = [];
                    var nodeencoding = [];
                    var edgeencoding = [];

                    //record the highlighted encodings
                    d3.selectAll('[bgcolor="#F3F315"]').each(function (d) {
                        var hienc = d3.select(this).attr('class');
                        var row = hienc.match(/row\d+/g)[0];
                        var col = hienc.match(/col\d+/g)[0];
                        var rowNum = row.replace('row','')
                        var encText = d3.selectAll('.enc'+rowNum).text();
                        // This is hacky, and should be properly done when I have time
                        if (rowNum > 9) {
                            edgeencoding.push(encText);
                        }
                        else {
                            nodeencoding.push(encText);
                        }
                    });

                    cy.nodes().map(function(n){
                        var temp = {};
                        temp.name = n.data().name;
                        temp.id = n.data().id;
                        temp.type = 'node';
                        temp.encoding1 = nodeencoding[0];
                        temp.encoding2 = nodeencoding[1];
                        temp.results = {};
                        selecnodeattrs.forEach(function(k){
                            temp.results[k] = n.style()[k];
                        });
                        temp.positions = n.position();
                        if (selectedElement.data().id === n.data().id) {
                            temp.selected = 1;
                        }
                        else {
                            temp.selected = 0;
                        }
                        console.log(temp);
                        tempdat.push(temp);
                    });

                    cy.edges().map(function(n){
                        var temp = {};
                        temp.id = n.data().id;
                        temp.source = n.data().source;
                        temp.target = n.data().target;
                        temp.type = 'edge';
                        //only one encoding for now
                        temp.encoding = edgeencoding;
                        temp.results = {};
                        selecedgeattrs.forEach(function(k){
                            temp.results[k] = n.style()[k];
                        });
                        if (selectedElement.data().id === n.data().id) {
                            temp.selected = 1;
                        }
                        else {
                            temp.selected = 0;
                        }
                        console.log(temp);
                        tempdat.push(temp);
                    });

                    $.ajax({
                        type: 'POST',
                        url: '/submitdata',
                        contentType: "application/json; charset=utf-8",
                        dataType: "json",
                        data: JSON.stringify(tempdat),
                        success: function (data) {
                            console.log(['user choice submit success', data]);
                            //re-layout graph (this also takes care of unselection)
//                            plotNetwork('genemania_BRCA');
                        },
                        complete: function() {
                            wholeWorkflow();
                        }
                    });

                });

                // Part of the timer function
//                $("#cy").load( (function () {
//                    var timerSeconds = 5,
//                            display = document.querySelector('#time');
//                    startTimer(timerSeconds, display);
//                })() );

            }
            else if (desireddata === "genemania_APP") {
                options.name = 'cose';
                cy = cytoscape({
                    container: document.getElementById('cy'),
                    elements: genemania_APP,
                    style: editStyle(generateStyle(), whichHighlight())
//                    selectionType: 'additive'
                });
            }
            else {
                cy = cytoscape({
                    container: document.getElementById('cy'),
                    elements: generateNetwork(parseInt($("#numNodes").val()) | 10, parseInt($("#numEdges").val()) | 15,['p-val','pathway'],['coexpression','probability']),
                    style: editStyle(generateStyle(), whichHighlight())
//                    selectionType: 'additive'
                });
            }

            cy.layout( options );
        }


        function generateStyle() {
            var style = [
                {
                    selector: 'node',
                    style: {
                        'background-color': 'red',
                        'shape': 'hexagon', //rectangle, roundrectangle, ellipse, triangle, pentagon, hexagon, heptagon, octagon, star, diamond, vee, rhomboid, or polygon
                        //'shape': encodingRenderFunctions['node shape (cat)']([1,2,3,4,5])
                        'width': null,
                        'height': null,
                        'border-width': 4,
                        'label': 'data(id)'
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 5,
                        'line-color': 'blue',
                        'line-style': 'dotted',   //solid, dotted, or dashed
                        'target-arrow-shape': 'triangle'
                    }
                }
            ];
            return style;
        }

        function editStyle(instyle, rows) {
            // rows are ['row1', 'row2', 'row4']
            var style = instyle;
            var attrs = {'nodes': [], 'edges': []};
            rows.forEach(function (r) {
                //ensure row has encoding in software
                if (Object.keys(enclookup).indexOf(r) !== -1) {
                    var type = enclookup[r].type;
                    var attr = enclookup[r].attribute;
                    console.log(type);
                    if (type === "node") {
                        attrs.nodes.push(attr);
                    }
                    else {
                        attrs.edges.push(attr);
                    }
                }
            });
            console.log(attrs);

            var node_attrs = Object.keys(style[0].style);
            var edge_attrs = Object.keys(style[1].style);

            // set style attribute to null unless highlighted
            for (var i = 0; i < node_attrs.length; i++) {
                if (attrs.nodes.indexOf(node_attrs[i]) === -1) {
                    style[0].style[node_attrs[i]] = null;
                }
            }

            for (var i = 0; i < edge_attrs.length; i++) {
                if (attrs.edges.indexOf(edge_attrs[i]) === -1) {
                    style[1].style[edge_attrs[i]] = null;
                }
            }

            return style;
        }


        function whichHighlight() {
            var items = [];
            d3.selectAll('.rankedcell').each(function (k) {
                var it = d3.select(this);
                var high = it.attr('bgcolor');
                var reg = /row\d+/g;
                console.log(high);
                if (high !== null) {
                    var row = it.attr('class').match(reg);
                    items.push(row[0]);
                }
            });
            return items.getUnique();
        }

    function getDomain(type, cond) {
        if (type === "node") {
            return cy.nodes(cond).map(function (val) {
                return val.data().value;
            }).getUnique();
        }
        else {
            return cy.edges(cond).map(function (val) {
                return val.data().value;
            }).getUnique();
        }
    }


    var thing = [
        {encname: 'node color (seq)', func: nodecolor_seq, style: 'background-color', type: 'node', range: [colorbrewer.Reds, colorbrewer.Blues, colorbrewer.Greens, colorbrewer.Greys][getRandomIntInclusive(0,3)], incompatability:[1,2,9,10,11,12,13,14,15]},
        {encname: 'node color (div)', func: nodecolor_div, style: 'background-color', type: 'node', range: colorbrewer.Spectral, incompatability:[0,2,9,10,11,12,13,14,15]},
        {encname: 'node color (cat)', func: nodecolor_cat, style: 'background-color', type: 'node', range: colorbrewer.Set2, incompatability:[0,1,9,10,11,12,13,14,15]},
        {
            encname: 'node shape (cat)',
            func: nodeshape_cat,
            style: 'shape',
            type: 'node',
            range: { 1: ["rectangle"],
                2: ["rectangle", "roundrectangle"],
                3: ["rectangle", "roundrectangle", "ellipse"],
                4: ["rectangle", "roundrectangle", "ellipse", "triangle"],
                5: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon"],
                6: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon"],
                7: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon"],
                8: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon"],
                9: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star"],
                10: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star", "diamond"],
                11: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star", "diamond", "vee"],
                12: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star", "diamond", "vee", "rhomboid"]
            },
            incompatability:[9,10,11,12,13,14,15]
        },
        {encname: 'node border (quant)', func: nodeborder_quant, style: 'border-width', type: 'node', range: [1, 5, 10], incompatability:[5,6,9,10,11,12,13,14,15]},
        {encname: 'node border (bin)', func: nodeborder_bin, style: 'border-width', type: 'node', range: [1, 5, 10], incompatability:[4,6,9,10,11,12,13,14,15]},
        {encname: 'node border (cat)', func: nodeborder_cat, style: 'border-width', type: 'node', range: [1, 5, 10], incompatability:[4,5,9,10,11,12,13,14,15]},
        {encname: 'node size (quant)', func: nodesize_quant, style: 'height', type: 'node', range: [20, 50, 75], incompatability:[8,9,10,11,12,13,14,15]},
        {encname: 'node size (bin)', func: nodesize_bin, style: 'height', type: 'node', range: [20, 50, 75], incompatability:[7,9,10,11,12,13,14,15]},
        {encname: 'edge width (quant)', func: edgewidth_quant, style: 'width', type: 'edge', range: [1, 5, 10], incompatability:[0,1,2,3,4,5,6,7,8,10]},
        {encname: 'edge width (bin)', func: edgewidth_bin, style: 'width', type: 'edge', range: [1, 5, 10], incompatability:[0,1,2,3,4,5,6,7,8,9]},
        {encname: 'edge color (seq)', func: edgecolor_seq, style: 'line-color', type: 'edge', range: colorbrewer.Greens, incompatability:[0,1,2,3,4,5,6,7,8,12,13]},
        {encname: 'edge color (div)', func: edgecolor_div, style: 'line-color', type: 'edge', range: colorbrewer.BuGn, incompatability:[0,1,2,3,4,5,6,7,8,11,13]},
        {encname: 'edge color (cat)', func: edgecolor_cat, style: 'line-color', type: 'edge', range: colorbrewer.Set3, incompatability:[0,1,2,3,4,5,6,7,8,11,12]},
        {
            encname: 'edge pattern (cat)',
            func: edgepattern_cat,
            style: 'line-style',
            type: 'edge',
            range: ["solid", "dotted", "dashed"],
            incompatability:[0,1,2,3,4,5,6,7,8]
        },
        {
            encname: 'edge arrow (cat)',
            func: edgearrow_cat,
            style: 'line-style',
            type: 'edge',
            range: ["solid", "dotted", "dashed"],
            incompatability:[0,1,2,3,4,5,6,7,8]
        }
    ];

    function rez(predomain,e) {
        if (Array.isArray(thing[e].range)) {
            console.log(e+" is an array");
            return thing[e].range.slice(0,predomain.length);
        }
        else {
            return thing[e].range[predomain.length | 3] || thing[e].range[ +d3.max(Object.keys(thing[e].range)) ];
        }
    }

    function makeThang(inputDimension, inputEncodings){
        var selector = '[dimension=\"'+inputDimension+'\"]';
        var sheet = {};
        inputEncodings.sort().forEach(function(e) {
            console.log([selector, e, thing[e].encname]);
            if (thing[e].type === "node") {
                var predomain = cy.nodes(selector).map(function(k){
                    if ($.isNumeric(k.data().value)) {
                        return +k.data().value;
                    }
                    else {
                        return k.data().value;
                    }
                });
                var prerange = function() {
//                    return thing[e].range[predomain.length | 3] || thing[e].range.slice(0,predomain.length) || thing[e].range[ +d3.max(Object.keys(thing[e].range)) ];
                    return rez(predomain,e);
                };
                var prefunc = thing[e].func(predomain,prerange());

//                for (var s=0;s<thing[e].style.length;s++) {
//                    sheet[ thing[e].style[s] ] = function( ele ) {
//                        return prefunc(ele.data().value);
//                    }
//                }

                sheet[ thing[e].style ] = function( ele ) {
                    return prefunc(ele.data().value);
                }
            }
            else {
                var predomain = cy.edges(selector).map(function(k){
                    if ($.isNumeric(k.data().value)) {
                        return +k.data().value;
                    }
                    else {
                        return k.data().value;
                    }
                });
                var prerange = function() {
//                    return thing[e].range[predomain.length | 3] || thing[e].range.slice(0,predomain.length) || thing[e].range[ +d3.max(Object.keys(thing[e].range)) ];
                    return rez(predomain,e);
                };
                var prefunc = thing[e].func(predomain,prerange());
//                for (var s=0;s<thing[e].style.length;s++) {
//                    sheet[ thing[e].style[s] ] = function( ele ) {
//                        return prefunc(ele.data().value);
//                    }
//                }
                sheet[ thing[e].style ] = function( ele ) {
                    return prefunc(ele.data().value);
                }
            }
        });
        console.log("sheet", sheet);
//        return cytoscape.stylesheet().selector(selector).style(sheet);
        return [selector,sheet];
    }

    function composeSelectors(arrOfSelectors) {
//        [   { selector: makeThang('pathway',[2,3])[0], style : makeThang('pathway',[2,3])[1] },
//            { selector: makeThang('p-val',[0,5])[0], style : makeThang('p-val',[0,5])[1] }   ]
        var ne = [];
        for (var i = 0; i < arrOfSelectors.length; i++) {
            ne.push( { selector: arrOfSelectors[i][0], style: arrOfSelectors[i][1]  } );
//            console.log(["selector", arrOfSelectors[i][0].replace('\"','\'').replace('\"','\''), "style", arrOfSelectors[i][1]]);
        }
        console.log(ne);
        return ne;
    }

function reviseViz() {
    // highlighted items
    var highlightedCells = [];
    d3.selectAll('[bgcolor="#F3F315"]').each(function (d) {
        var hienc = d3.select(this).attr('class');
        var row = hienc.match(/row\d+/g)[0];
        var col = hienc.match(/col\d+/g)[0];
        highlightedCells.push({encoding: row, dim: col});
    });

    // Get unique dimension names
    var uniqueDims = Object.keys(manifest).map(function (k) {
        return manifest[k].name;
    }).getUnique();

    var makecomposeselectorInput = [];
    for (var q = 0; q < uniqueDims.length; q++) {
        // Get indexes of columns of first dimension in array. I need to match these numbers to highlightedcell dim numbers
        var toMatchtoHC = Object.keys(manifest).map(function (k,i) {
            if (manifest[k].name === uniqueDims[q]) {
                return i;
            }
        }).filter(function( element ) {
            return element !== undefined;
        });

        // Only retrieve manifest columns of matched numbers
        // Use this step to obtain encoding row numbers (for thing lookup)
        var encToUse = highlightedCells.map(function(n){ if ( toMatchtoHC.indexOf(+n.dim.replace('col','')-1)!== -1 ) { return n; }  }).filter(function( element ) {
            return element !== undefined;
        }).map(function(n) { return +n.encoding.replace('row','')-1; });

        makecomposeselectorInput.push( makeThang(uniqueDims[q], encToUse) )
    }

//    composeSelectors( [ makeThang('pathway',[3,6]), makeThang('p-val',[1,4])  ] )
    console.log('makecomposeselectorInput', makecomposeselectorInput);
    return composeSelectors( makecomposeselectorInput );
}

function newlayout(l) {
    cy.makeLayout({
        name: l
    }).run();
}


window.onkeypress = function(event) {
    if (event.keyCode == 113) {
        // do random
        randomRanks();
    }
    else if (event.keyCode == 97) {
        // load ranks
        generateBaselineRank(taskNames[parseInt($('#taskChoice').val()) || 3]);
    }
    else if (event.keyCode == 119) {
        // send table
        sendToR();
    }
    else if (event.keyCode == 101) {
        // dynamo
        internalData();
    }
    else if (event.keyCode == 114) {
        // reset viz
        plotNetwork();
    }
    else if (event.keyCode == 115) {
        submitUserChoice();
    }
};

    function overEncoding(numberOfClasses) {
        var rangematrix = [];
        for (var i=0; i < thing.length; i++) {
            for (var k=i+1; k < thing.length; k++) {
                var one;
                var two;
                if ( !Array.isArray(thing[i].range ) ) {
                    one = +d3.max(Object.keys(thing[i].range))
                }
                else {
                    one = thing[i].range.length;
                }
                if ( !Array.isArray(thing[k].range ) ) {
                    two = +d3.max(Object.keys(thing[k].range))
                }
                else {
                    two = thing[k].range.length;
                }
                console.log([i,k,thing[i],thing[k],one,two])
                if (thing[i].incompatability.indexOf(k) === -1) {
                    rangematrix.push({indexes:[i,k], potential:one*two})
                }
            }
        }

        // calculate difference between numberOfClasses and potentials
        var retrangematr = rangematrix.map(function(n){
                    return {indexes:n.indexes, potential:n.potential-numberOfClasses};
                }).filter(function(n){
                    if (n.potential >=0) {
                        return {indexes:n.indexes, potential:n.potential}
                    }
                }).sort(function(a,b){
                    return a.potential-b.potential
                });

        return retrangematr;
    }

    function swap(json){
        var ret = {};
        for(var key in json){
            ret[json[key]] = key;
        }
        return ret;
    }


    var baselineMappings = {
        "Saturation..Brightness": ["node color (seq)", "node color (div)"],
        "Color" : ["node color (cat)"],
        "Shape..Icon": ["node shape (cat)"],
        "Weight..Boldness": ["node border (quant)", "node border (bin)"],
        "Size.Area" : ["node size (quant)", "node size (bin)"],
        "Size.Area.1": ["edge width (quant)", "edge width (bin)"],
        "Saturation..Brightness.1" : ["edge color (seq)", "edge color (div)"],
        "Color.1" : ["edge color (cat)"],
        "Shape..Icon.1" : ["edge pattern (cat)"],
        "Text" : ["node label (cat)"],
        "Text.1" : ["edge label (cat)"]
    };

    var baselineValues;
    var taskNames;

    $(document).ready(function() {
        d3.csv('/ranktable.csv', function(err, data) {
            if(err === null) {
                data.forEach(function(item){
                    if(item.hasOwnProperty('')) {
                        item['Encoding'] = item[''];
                        delete item[''];
                    }
                });
                baselineValues = data;
                taskNames = Object.keys(baselineValues[0]);

                // To initialize app on loadig page
                updateTableDimensions();
                hideExtraneous();
                wholeWorkflow();
            }
            else {
                console.log('This is embarassing!')
            }
        });
    });


    function hideExtraneous() {
        $('#rankTableSection').hide();
        $('#layoutButtonSection').hide();
        $('#rankTable').hide();
    }

    function showExtraneous() {
        $('#rankTableSection').show();
        $('#layoutButtonSection').show();
        $('#rankTable').show();
    }

    function wholeWorkflow() {

        // Clearing the interval for when user clicks and time does not run out
//        clearInterval(newtime)

            function randRanksAndSendToR() {
                // sendToR function
                d3.selectAll(  (function () {
                    // randomRanks function
                    if (randomRanks() === 0) {
                        return '.rankedcell'
                    }
                    else {
                        console.log('Problem with randomrank generator');
                    }
                })()  ).attr('bgcolor', null);


                highlightImproperEncodings();

                $.ajax({
                    type: 'POST',
                    url: 'lp',
                    contentType: "application/json; charset=utf-8",
                    dataType: "json",
                    data: JSON.stringify({table: rankTableToJSON(), toAssign: getNumberOfAssignments()}),
                    success: function (data, statusText, xhrObj) {
                        console.log("SUCCESS");
                        Robj = data;
                        highlightAssignedCells();
                        plotNetwork('genemania_BRCA');
                        console.log(data);
                    },
                    complete: function() {
                        return (function() {
                            try {
                                cy.style(reviseViz());
                                //make sure that the node width is symmetrical to height
                                cy.nodes().style('width', function(n){return n.height();});
                            } catch(err) {
                                console.log(err);
                                cy.style(reviseViz().reverse());
                                //make sure that the node width is symmetrical to height
                                cy.nodes().style('width', function(n){return n.height();});
                            }
                        })();
                    }
                });
            };

        return randRanksAndSendToR();

    }

    //To record mouse position. Could make it on 'click' instead of 'mouseover'
//    cy.on('mousemove', function() {
//        console.log([window.event.clientX, window.event.clientY])
//    })

//    function submitUserChoice() {
//        var tosub = recordData();
//        return $.ajax({
//            type: 'POST',
//            url: '/submitdata',
//            contentType: "application/json; charset=utf-8",
//            dataType: "json",
//            data: JSON.stringify(tosub),
//            success: function (data) {
//                console.log(['user choice submit success', data]);
////                plotNetwork('genemania_BRCA');
//            }
//        });
//    }

//    function recordData() {
//        //record node data
//        cy.on('select', 'node,edge', function(ev) {
//            console.log(ev);
//            var selectedElement = ev.cyTarget;
//            console.log(["CLICKERED", selectedElement.data()]);
//
//            var selecnodeattrs = thing.map(function(n){ if(n.type==="node"){ return n.style; } }).filter(function(n){ return n != undefined }).getUnique();
//            var selecedgeattrs = thing.map(function(n){ if(n.type==="edge"){ return n.style; } }).filter(function(n){ return n != undefined }).getUnique();
//            var tempdat = [];
//            var nodeencoding;
//            var edgeencoding;
//
//            //record the highlighted encodings
//            d3.selectAll('[bgcolor="#F3F315"]').each(function (d) {
//                var hienc = d3.select(this).attr('class');
//                var row = hienc.match(/row\d+/g)[0];
//                var col = hienc.match(/col\d+/g)[0];
//                var rowNum = row.replace('row','')
//                var encText = d3.selectAll('.enc'+rowNum).text();
//                // This is hacky, and should be properly done when I have time
//                if (rowNum > 9) {
//                    edgeencoding = encText;
//                }
//                else {
//                    nodeencoding = encText;
//                }
//            });
//
//            cy.nodes().map(function(n){
//                var temp = {};
//                temp.name = n.data().name;
//                temp.id = n.data().id;
//                temp.type = 'node';
//                temp.encoding = nodeencoding;
//                temp.results = {};
//                selecnodeattrs.forEach(function(k){
//                    temp.results[k] = n.style()[k];
//                });
//                temp.positions = n.position();
//                if (selectedElement.data().id === n.data().id) {
//                    temp.selected = 1;
//                }
//                console.log(temp);
//                tempdat.push(temp);
//            });
//
//            cy.edges().map(function(n){
//                var temp = {};
//                temp.id = n.data().id;
//                temp.source = n.data().source;
//                temp.target = n.data().target;
//                temp.type = 'edge';
//                temp.encoding = edgeencoding;
//                temp.results = {};
//                selecedgeattrs.forEach(function(k){
//                    temp.results[k] = n.style()[k];
//                });
//                if (selectedElement.data().id === n.data().id) {
//                    temp.selected = 1;
//                }
//                console.log(temp);
//                tempdat.push(temp);
//            });
//
//            return tempdat;
//        });
//
////        cy.nodes(':selected').map(function(n){
////            var temp = {};
////            temp.name = n.data().name;
////            temp.id = n.data().id;
////            temp.type = 'node';
////            temp.encoding = nodeencoding;
////            temp.results = {};
////            selecnodeattrs.forEach(function(k){
////                temp.results[k] = n.style()[k];
////            });
////            temp.positions = n.position();
////            temp.selected = 1;
////            console.log(temp);
////            tempdat.push(temp);
////        });
////
////        cy.nodes(':unselected').map(function(n){
////            var temp = {};
////            temp.name = n.data().name;
////            temp.id = n.data().id;
////            temp.type = 'node';
////            temp.encoding = nodeencoding;
////            temp.results = {};
////            selecnodeattrs.forEach(function(k){
////                temp.results[k] = n.style()[k];
////            });
////            temp.positions = n.position();
////            temp.selected = 0;
////            console.log(temp);
////            tempdat.push(temp);
////        });
//
//        //record edge data
////        cy.edges(':selected').map(function(n){
////            var temp = {};
////            temp.id = n.data().id;
////            temp.source = n.data().source;
////            temp.target = n.data().target;
////            temp.type = 'edge';
////            temp.encoding = edgeencoding;
////            temp.results = {};
////            selecedgeattrs.forEach(function(k){
////                temp.results[k] = n.style()[k];
////            });
////            temp.selected = 1;
////            console.log(temp);
////            tempdat.push(temp);
////        });
//
////        cy.edges(':unselected').map(function(n){
////            var temp = {};
////            temp.id = n.data().id;
////            temp.source = n.data().source;
////            temp.target = n.data().target;
////            temp.type = 'edge';
////            temp.encoding = edgeencoding;
////            temp.results = {};
////            selecedgeattrs.forEach(function(k){
////                temp.results[k] = n.style()[k];
////            });
////            temp.selected = 0;
////            console.log(temp);
////            tempdat.push(temp);
////        });
//
////        return tempdat;
//    }



//    baselineValues.forEach(function(b){
//        if (Object.keys(baselineMappings).indexOf(b.Encoding) !== -1){
//            baselineMappings[b.Encoding].forEach(function(enc){
//                console.log([enc, +b['Task_Topology_Find_Clusters']])
//            })
//        }
//    })

    // to calculate set space, dim1 task1 * dim2 task1 + dim1task2 * dim2task2
    // could be better to separate into node and edge encoding set spaces


    // to record information from selected elements
    //var selectedNodeStyleAttrs = thing.map(function(n){ if(n.type==="node"){ return n.style; } }).filter(function(n){ return n != undefined }).getUnique().map(function(n){ return cy.nodes(':selected').style()[n]; });
    //var selectedEdgeStyleAttrs = thing.map(function(n){ if(n.type==="edge"){ return n.style; } }).filter(function(n){ return n != undefined }).getUnique().map(function(n){ return cy.edges(':selected').style()[n]; });


</script>
</html>


