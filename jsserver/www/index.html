<!DOCTYPE html>
<head>
    <!--<script src="http://code.jquery.com/jquery-2.1.0.min.js"></script>-->
    <meta charset="utf-8">
    <title>Visual Encoding App</title>
    <!--<script src="http://d3js.org/d3.v3.min.js"></script>-->
    <!--<script src="http://localhost:3000/bundle.js"></script>-->
    <!--<script data-main="main.js" src="require.js"></script>-->
    <script src="colorbrewer.js"></script>
    <script src="cytoscape.js"></script>
    <script src="d3.js"></script>
    <script src="jquery.js"></script>
    <script src="fcns.js"></script>
    <!--<script src="http://localhost:3000/bundle.js"></script>-->
    <!--<script src="node_modules/cytoscape/src/index.js"></script>-->
    <!--<script src="node_modules/jquery/src/jquery.js"></script>-->
    <!--<script src="node_modules/d3/d3.min.js"></script>-->
    <style>
        #cy {
            width: 100%;
            height: 50%;
            position: absolute;
            top: 300px;
            left: 0px;
            display: none;
        }
    </style>
</head>
<div id="rankTableSection">
    <input id="numEncodings">
    <input id="numTasks">
    <button id="updateTableDim" onclick="updateTableDimensions()">update table</button>
    <button id="randvalues" onclick="randomRanks()">generate random ranks</button>
    <button id="sendranktable" onclick="sendToR()">send table</button>
    <button id="visualizeNetwork" onclick="plotNetwork()">visualize default</button>
    <button id="updateVisualizedNetwork" onclick="internalData()">Dyanmo!</button>
</div>
<div id="uploadGraphSection">
    <div id="dvImportSegments" class="fileupload">
        <fieldset>
            <legend>Upload your Network File</legend>
            <input type="file" name="File Upload" id="txtFileUpload" />
        </fieldset>
    </div>
</div>
<div id="cy">
</div>
</body>
<script type="application/javascript">

    Array.prototype.getUnique = function(){
        var u = {}, a = [];
        for(var i = 0, l = this.length; i < l; ++i){
            if(u.hasOwnProperty(this[i])) {
                continue;
            }
            a.push(this[i]);
            u[this[i]] = 1;
        }
        return a;
    }

    var body = d3.select('body');

    var numberOfEncodings = 5;
    var numberOfTasks = 5;
    var cy;
    var tasks = [];
    var encodings;
    var Robj;
    var taskWithDims = [];

    var dims = ['dim1', 'dim2', 'dim3'];
    var encs = ['node color (seq)',
        'node color (div)',
        'node color (cat)',
        'node shape (cat)',
        'node border (quant)',
        'node border (bin)',
        'node border (cat)', //patterns
        'edge width (quant)',
        'edge width (bin)',
        'edge color (seq)',
        'edge color (div)',
        'edge color (cat)',
        'edge pattern (cat)',
        'edge arrow (cat)'];


    var enclookup = {'row1': {'type':'node','attribute':'background-color'}, //can define function to use here?
                    'row2': {'type':'node','attribute':'border-width'},
                    'row3': {'type':'edge','attribute':'width'},
                    'row4': {'type':'edge','attribute':'line-color'},
                    'row5': {'type':'edge','attribute':'line-style'},
                    'row6': {'type':'edge','attribute':'target-arrow-shape'}
    };
    // Nodes
    // background-blacken
    // background-opacity
    // border-width
    // border-style
    // border-color
    // border-opacity
    //
    // Edges
    // curve-style
    // segment-distances (for edges made of several straight lines)
    // <pos>-arrow-color
    // <pos>-arrow-shape
    // <pos>-arrow-fill
    //
    // Labels
    // label
    // source-label
    // target-label (and also font styling among other things)

    // I need to clarify usage between manifest and cytoscape data, and also clarify how type and usage are different
    // and used. In a nutshell, it doesn't look like the highlightimproperencodings function is working the way I
    // want, and I think it's due to the way I've defined and used some of these terms
    var manifest = {
        'dim1 task1' : {type: 'numeric', usage: ['numeric'], name: 'p-val', element: 'node', ind:0 },
        'dim1 task2' : {type: 'numeric', usage: ['numeric'], name: 'p-val', element: 'node', ind:1 },
        'dim2 task1' : {type: 'numeric', usage: ['numeric'], name: 'coexpression', element: 'edge', ind:2 },
        'dim2 task2' : {type: 'numeric', usage: ['numeric'], name: 'coexpression', element: 'edge', ind:3 },
        'dim3 task1' : {type: 'categorical', usage: ['categorical'], name: 'pathway', element: 'node', ind:4 },
        'dim3 task2' : {type: 'categorical', usage: ['categorical'], name: 'pathway', element: 'node', ind:5 }
    };

    function internalData() {

        // highlighted items
        var highlightedCells = [];
        d3.selectAll('[bgcolor="#F3F315"]').each(function (d) {
            var hienc = d3.select(this).attr('class');
            var row = hienc.match(/row\d+/g)[0];
            var col = hienc.match(/col\d+/g)[0];
            highlightedCells.push({encoding: row, dim: col});
        });

        //keep thing in same order as encoding rows so I can do array lookup
        var thing = [
            {encname: 'node color (seq)', func: nodecolor_seq, style: 'background-color', type: 'node', range: colorbrewer.Reds},
            {encname: 'node color (div)', func: nodecolor_div, style: 'background-color', type: 'node', range: colorbrewer.RdBu},
            {encname: 'node color (cat)', func: nodecolor_cat, style: 'background-color', type: 'node', range: colorbrewer.Set2},
            {
                encname: 'node shape (cat)',
                func: nodeshape_cat,
                style: 'shape',
                type: 'node',
//                range: [ ["rectangle"], ["roundrectangle"], ["ellipse"], ["triangle"], ["pentagon"], ["hexagon"], ["heptagon"], ["octagon"], ["star"], ["diamond"], ["vee"], ["rhomboid"] ]
                range: { 1: ["rectangle"],
                    2: ["rectangle", "roundrectangle"],
                    3: ["rectangle", "roundrectangle", "ellipse"],
                    4: ["rectangle", "roundrectangle", "ellipse", "triangle"],
                    5: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon"],
                    6: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon"],
                    7: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon"],
                    8: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon"],
                    9: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star"],
                    10: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star", "diamond"],
                    11: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star", "diamond", "vee"],
                    12: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star", "diamond", "vee", "rhomboid"] }
            },
            {encname: 'node border (quant)', func: nodeborder_quant, style: 'border-width', type: 'node', range: [1, 5, 10]},
            {encname: 'node border (bin)', func: nodeborder_bin, style: 'border-width', type: 'node', range: [1, 5, 10]},
            {encname: 'node border (cat)', func: nodeborder_cat, style: 'border-width', type: 'node', range: [1, 5, 10]},
            {encname: 'edge width (quant)', func: edgewidth_quant, style: 'width', type: 'edge', range: [1, 5, 10]},
            {encname: 'edge width (bin)', func: edgewidth_bin, style: 'width', type: 'edge', range: [1, 5, 10]},
            {encname: 'edge color (seq)', func: edgecolor_seq, style: 'line-color', type: 'edge', range: colorbrewer.Blues},
            {encname: 'edge color (div)', func: edgecolor_div, style: 'line-color', type: 'edge', range: colorbrewer.BuGn},
            {encname: 'edge color (cat)', func: edgecolor_cat, style: 'line-color', type: 'edge', range: colorbrewer.Set3},
            {
                encname: 'edge pattern (cat)',
                func: edgepattern_cat,
                style: 'line-style',
                type: 'edge',
                range: ["solid", "dotted", "dashed"]
            },
            {
                encname: 'edge arrow (cat)',
                func: edgearrow_cat,
                style: 'line-style',
                type: 'edge',
                range: ["solid", "dotted", "dashed"]
            }
        ];

        var colorfuncs = [nodecolor_cat, nodecolor_div, nodecolor_seq,
            edgecolor_cat, edgecolor_div, edgecolor_seq];

        // for each highlight, get the column (dimension) and row (encoding)
//        var dim_task = cy.nodes().map(function(k) { return(k.data().dimension) }).getUnique();

        highlightedCells.forEach(function (rc) {
            var columnNumber = rc.dim.replace('col', '');
            var rowNumber = rc.encoding.replace('row', '');
            var arrayOfDimTask = Object.keys(manifest).map(function (k) {
                return manifest[k];
            });
            var condition = "[dimension=\'" + arrayOfDimTask[columnNumber - 1].name + "\']";
            var ele = thing[rowNumber - 1];
            console.log([condition, ele.encname, ele.func, rowNumber, columnNumber, ele ]);


            if (ele.type === "node") {
                var tempdomain = getDomain(ele.type, condition);
                var temprange = function() {
                    return ele.range[tempdomain.length | 3] || ele.range.slice(0,tempdomain.length);
                };
                var specificfunc = ele.func(
                        tempdomain,
                        temprange()
                );

                cy.nodes(condition).css( ele.style, function(n) {
                    console.log([ 'node', tempdomain, temprange(), n.data().value, specificfunc(n.data().value) ]);
//                    return n.css(ele.style); // this is so it won't complain that cytoscape doesn't take null setter values
                    return specificfunc(n.data().value);
                })
            }
            else {
                var tempdomain = getDomain(ele.type, condition);
                var temprange = function() {
                    return ele.range[tempdomain.length | 3] || ele.range.slice(0,tempdomain.length);
                };
                var specificfunc = ele.func(
                        tempdomain,
                        temprange()
                );

                cy.edges(condition).css( ele.style, function(n) {
                    console.log([ 'edge', tempdomain, temprange(), n.data().value, specificfunc(n.data().value) ]);
//                    return n.css(ele.style); // this is so it won't complain that cytoscape doesn't take null setter values
                    return specificfunc(n.data().value);
                })
            }

        });
    }

    function dataHierarchy(input) {
        if (input === 'numeric') {
            return ['numeric','categorical'];
        }
        else if (input === 'categorical') {
            return ['categorical'];
        }
        else {
            return ['error'];
        }
    }


        var allowedEncodings = {
            'node color (seq)': ['numeric'],
            'node color (div)': ['numeric'],
            'node color (cat)': ['categorical'], // seems to work better when set to numeric..
            'node shape (cat)': ['categorical'],
            'node border (quant)': ['numeric'],
            'node border (bin)': ['numeric'],
            'node border (cat)': ['categorical'], //patterns
            'edge width (quant)': ['numeric'],
            'edge width (bin)': ['numeric'],
            'edge color (seq)': ['numeric'],
            'edge color (div)': ['numeric'],
            'edge color (cat)': ['categorical'],
            'edge pattern (cat)': ['categorical'],
            'edge arrow (cat)': ['categorical']
        };


        var encodingRenderFunctions = {
            'node color (seq)':    {func:nodecolor_seq, intype:['numeric'], outtype:['categorical'], element:'node', ind:0},
            'node color (div)':    {func:nodecolor_div, intype:['numeric'], outtype:['categorical'], element:'node', ind:1},
            'node color (cat)':    {func:nodecolor_cat, intype:['numeric', 'categorical'], outtype:['categorical'], element:'node', ind:2},
            'node shape (cat)':    {func:nodeshape_cat, intype:['numeric', 'categorical'], outtype:['categorical'], element:'node', ind:3},
            'node border (quant)': {func:nodeborder_quant,intype:['numeric'], outtype:['numeric'], element:'node', ind:4},
            'node border (bin)':   {func:nodeborder_bin,intype:['numeric'], outtype:['categorical'], element:'node', ind:5},
            'node border (cat)':   {func:nodeborder_cat,intype:['numeric', 'categorical'], outtype:['categorical'], element:'node', ind:6},
            'edge width (quant)':  {func:edgewidth_quant,intype:['numeric'], outtype:['numeric'], element:'edge', ind:7},
            'edge width (bin)':    {func:edgewidth_bin,intype:['numeric'], outtype:['categorical'], element:'edge', ind:8},
            'edge color (seq)':    {func:edgecolor_seq,intype:['numeric'], outtype:['categorical'], element:'edge', ind:9},
            'edge color (div)':    {func:edgecolor_div,intype:['numeric'], outtype:['categorical'], element:'edge', ind:10},
            'edge color (cat)':    {func:edgecolor_cat,intype:['numeric', 'categorical'], outtype:['categorical'], element:'edge', ind:11},
            'edge pattern (cat)':  {func:edgepattern_cat,intype:['numeric', 'categorical'], outtype:['categorical'], element:'edge', ind:12},
            'edge arrow (cat)':    {func:edgearrow_cat, intype:['numeric', 'categorical'], outtype:['categorical'], element:'edge', ind:13}
        };

        var encodingStyleFunctions = {
            'node color (seq)': {name: 'background-color', param: colorbrewer.Reds},
            'node color (div)': {name: 'background-color', param: colorbrewer.RdBu},
            'node color (cat)': {name: 'background-color', param: colorbrewer.Set2},
            'node shape (cat)': {name: 'shape'},
            'node border (quant)': {name: 'border-width'},
            'node border (bin)': {name: 'border-width'},
            'node border (cat)': {name: 'border-width'},
            'edge width (quant)': {name: 'width'},
            'edge width (bin)': {name: 'width'},
            'edge color (seq)': {name: 'line-color'},
            'edge color (div)': {name: 'line-color'},
            'edge color (cat)': {name: 'line-color'},
            'edge pattern (cat)': {name: 'line-style'},
            'edge arrow (cat)': {name: 'target-arrow-shape'}
        };
        // encodingRenderFunctions['node shape (cat)']([1,2,3,4,5])

        function highlightImproperEncodings() {
            //allowedEncodings['edge pattern'].indexOf(manifest["dim1 task 1"].usage) === -1 then improper
            //d3.selectAll('.rankedcell').attr('bgcolor', null);
            var encodingsWithNamesReplaced = [];
            for (var i = 1; i < encodings.length + 1; i++) {
                encodingsWithNamesReplaced.push(d3.selectAll('.enc' + i).text());
            }

            console.log(encodingsWithNamesReplaced);

            for (var t = 0; t < tasks.length; t++) {
                for (var e = 0; e < encodingsWithNamesReplaced.length; e++) {
                    if (Object.keys(allowedEncodings).indexOf(encodingsWithNamesReplaced[e]) !== -1) {
                        console.log([  t, tasks[t], e, encodingsWithNamesReplaced[e], manifest[tasks[t]].type, encodingRenderFunctions[encodingsWithNamesReplaced[e]].intype  ]);
                        // invalidate cells with conflicting data types
                        if (encodingRenderFunctions[encodingsWithNamesReplaced[e]].intype.indexOf(manifest[tasks[t]].type) === -1) {
                            d3.selectAll('.col' + (t + 1))
                                    .filter('.row' + (e + 1))
                                    .attr('bgcolor', 'gray')
                                    .text('0');
                        }
                        // ensure node dims not assigned to edge encodings, and visa-versa
                        if (encodingRenderFunctions[encodingsWithNamesReplaced[e]].element !== manifest[tasks[t]].element) {
                            d3.selectAll('.col' + (t + 1))
                                    .filter('.row' + (e + 1))
                                    .attr('bgcolor', 'gray')
                                    .text('0');
                        }
                    }
                }
            }
        }

        function updateTableDimensions() {
            numberOfEncodings = parseInt($("#numEncodings").val());
            numberOfTasks = parseInt($("#numTasks").val());
//        numberOfEncodings = parseInt(d3.select('#numEncodings')[0][0].value);
//        numberOfTasks = parseInt(d3.select('#numTasks')[0][0].value);
            console.log(numberOfEncodings);
            console.log(numberOfTasks);
            createTable(numberOfEncodings, numberOfTasks);
            for (var i = 0; i < encs.length; i++) {
                d3.select('.enc' + (i + 1)).text(encs[i]);
            }
        }

        function createTable(numberOfEncodings, numberOfTasks) {
            $('#rankTable').remove();
            tasks = [];
//        tasks = makeTasks(numberOfTasks);
            encodings = makeEncodings(numberOfEncodings);
            for (var d = 0; d < dims.length; d++) {
                for (var e = 0; e < makeTasks(numberOfTasks).length; e++) {
                    tasks.push(dims[d] + ' ' + makeTasks(numberOfTasks)[e]);
                }
            }
            console.log(encodings);
            console.log(tasks);
            var tabl = makeTable(encodings.length, tasks.length);
        }


        function makeTable(nr, nc) {
            var table = body.append("table")
                    .attr("id", "rankTable");
            var trData = [];

            d3.range(0, nr + 1).forEach(function (r) {
                var tr = table.append("tr");
                var tdData = [];
                d3.range(0, nc + 1).forEach(function (c) {
                    var td = tr.append("td")
                            .attr('contenteditable', 'true')
                            .text(function () {
                                if (r === 0) {
                                    return tasks[c - 1];
                                }
                                if (c === 0) {
                                    return encodings[r - 1];
                                }
                                return "(" + r + "," + c + ")";
                            })
                            .attr("id", function () {
                                if (r === 0) {
                                    return tasks[c - 1];
                                }
                                if (c === 0) {
                                    return encodings[r - 1];
                                }
                                return "cell_row" + r + "_col" + c;
                            })
                            .attr("class", function () {
                                if (r === 0) {
                                    return tasks[c - 1];
                                }
                                if (c === 0) {
                                    return encodings[r - 1];
                                }
                                return "rankedcell row" + r + " col" + c;
                            });
                    ;
                    tdData.push(td);
                });
                trData.push(tr);
            });
            return (trData);
        }

        function randomRanks() {
            d3.selectAll('.rankedcell').attr('bgcolor', null);
            for (var i = 1; i < tasks.length + 1; i++) {
                console.log(numberOfEncodings);
                var ranks = generateArrayofValues(numberOfEncodings);
                console.log(ranks);
                d3.selectAll(".col" + i)
                        .data(ranks)
                        .text(function (d) {
                            return d;
                        });
            }


            function generateArrayofValues(nrows) {
                var arr = [];
                d3.range(1, nrows + 1).forEach(function (k) {
                    arr.push(getRandomIntInclusive(1, nrows));
                });
                return shuffle(arr);
            }

            function getRandomIntInclusive(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            function shuffle(array) {
                var currentIndex = array.length, temporaryValue, randomIndex;

                // While there remain elements to shuffle...
                while (0 !== currentIndex) {

                    // Pick a remaining element...
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex -= 1;

                    // And swap it with the current element.
                    temporaryValue = array[currentIndex];
                    array[currentIndex] = array[randomIndex];
                    array[randomIndex] = temporaryValue;
                }

                return array;
            }

        }

        function sendToR() {
            d3.selectAll('.rankedcell').attr('bgcolor', null);
            highlightImproperEncodings();
            var jsontable = rankTableToJSON();
            console.log(jsontable);


            return $.ajax({
                type: 'POST',
                url: 'lp',
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: JSON.stringify(jsontable),
                success: function (data) {
                    console.log(data);
                    Robj = data;
                    highlightAssignedCells();
                    return data;
                }
            });
        }

        function uploadUserNetwork() {
            // this function needs work before it will run
            var file = $.get('#txtFileUpload');


            return $.ajax({
                type: 'POST',
                url: 'convert',
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: JSON.stringify(file),
                success: function (data) {
                    console.log(data);
                    return data;
                }
            });
        }


        function rankTableToJSON() {
            return $('table#rankTable tr').get().map(function (row) {
                return $(row).find('td').get().map(function (cell) {
                    return $(cell).html();
                });
            });
        }

        function makeTasks(amount) {
            return d3.range(1, amount + 1).map(function (a) {
                return "task" + a;
            });
        }

        function makeEncodings(amount) {
            return d3.range(1, amount + 1).map(function (a) {
                return "enc" + a;
            });
        }

        function highlightAssignedCells() {
//        d3.selectAll('.rankedcell').attr('bgcolor', null);
            var assignments = Robj;
            var numcols = Object.keys(Robj).length;
            console.log(numcols);
            for (var i = 0; i < numcols; i++) {
//            var row = assignments[Object.keys(Robj)[i]].indexOf(1);
                var row = assignments[Object.keys(Robj)[i]].map(function (d, i) {
                    if (d === 1) {
                        return i;
                    }
                }).filter(function (d) {
                    return d !== undefined
                });
                for (var k = 0; k < row.length; k++) {
                    var cellAssignment = d3.selectAll('.col' + (i + 1))
                            .filter('.row' + (row[k] + 1))
                            .attr('bgcolor', "#F3F315");
                }
            }
        }

        function plotNetwork() {
            var cyCanvas = d3.selectAll('#cy')
                    .style('display', 'inline');

            cy = cytoscape({
                container: document.getElementById('cy'),
                elements: [
                    {data: {id: 'a', value: 40, usage: 'numeric', dimension: 'p-val'}},
                    {data: {id: 'b', value: 25, usage: 'numeric', dimension: 'p-val'}},
//                    {data: {id: 'c', value: 15, usage: 'numeric', dimension: 'p-val'}},
//                    {data: {id: 'd', value: 115, usage: 'numeric', dimension: 'p-val'}},
                    {data: {id: 'e', value: "group1", usage: 'categorical', dimension: 'pathway'}},
                    {data: {id: 'f', value: "group2", usage: 'categorical', dimension: 'pathway'}},
                    {data: {id: 'g', value: "group2", usage: 'categorical', dimension: 'pathway'}},
                    {
                        data: {
                            id: 'ab',
                            source: 'a',
                            target: 'b',
                            dimension: 'coexpression',
                            value: 20,
                            usage: 'numeric'
                        }
                    },
                    {
                        data: {
                            id: 'bf',
                            source: 'b',
                            target: 'f',
                            dimension: 'coexpression',
                            value: 30,
                            usage: 'numeric'
                        }
                    },
                    {
                        data: {
                            id: 'af',
                            source: 'a',
                            target: 'f',
                            dimension: 'coexpression',
                            value: 10,
                            usage: 'numeric'
                        }
                    }],
//            style: generateStyle()
                style: editStyle(generateStyle(), whichHighlight())
//                style: cytoscape.stylesheet()
//                    .selector('[dimension="p-val"]')
//                    .style({
//                        'background-color': function( ele ) {
//                            var predomain = cy.nodes('[dimension="p-val"]').map(function(k){return k.data().value});
//                            console.log(['heyho', ele.data(), predomain]);
//                            return 'green';
//                        }
//                    })
            });


//        var cy = cytoscape(makeRandomNetwork());
//        var options = {
//            name: 'random',
//
//            fit: true, // whether to fit to viewport
//            padding: 30, // fit padding
//            boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
//            animate: false, // whether to transition the node positions
//            animationDuration: 500, // duration of animation in ms if enabled
//            animationEasing: undefined, // easing of animation if enabled
//            ready: undefined, // callback on layoutready
//            stop: undefined // callback on layoutstop
//        };
//
//        cy.layout( options );
        }

//        var stylein = {
//            'background-color': {func: encodingRenderFunctions['node shape (cat)']([1, 2, 3, 4, 5])},
//            'node color (cat)': ['a', 'b', 'c', 'd']
//        }; //could this be input to generateStyle?

        function generateStyle() {
            var style = [
                {
                    selector: 'node',
                    style: {
                        'background-color': 'red',
                        'shape': 'hexagon', //rectangle, roundrectangle, ellipse, triangle, pentagon, hexagon, heptagon, octagon, star, diamond, vee, rhomboid, or polygon
                        //'shape': encodingRenderFunctions['node shape (cat)']([1,2,3,4,5])
                        'width': null,
                        'height': null,
                        'border-width': 4
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 5,
                        'line-color': 'blue',
                        'line-style': 'dotted',   //solid, dotted, or dashed
                        'target-arrow-shape': 'triangle'
                    }
                }
//                {
//                    selector: '[dimension="p-val"]',
//                    style: {
//                        'width': 50,
//                        'background-color': function(n) {
//                            var tdom = cy.nodes('[dimension="p-val"]').map(function(h) {return h.data().value});
//                            var prefunc = d3.scale.ordinal.domain(tdom).range(d3.extent(colorbrewer.Greens[4]));
//                            console.log([tdom, d3.extent(colorbrewer.Greens[4]), prefunc]);
//                            return  prefunc(n.data().value)
//                        }
//                    }
//                }
            ];
            return style;
        }

        function editStyle(instyle, rows) {
            // rows are ['row1', 'row2', 'row4']
            var style = instyle;
            var attrs = {'nodes': [], 'edges': []};
            rows.forEach(function (r) {
                //ensure row has encoding in software
                if (Object.keys(enclookup).indexOf(r) !== -1) {
                    var type = enclookup[r].type;
                    var attr = enclookup[r].attribute;
                    console.log(type);
                    if (type === "node") {
                        attrs.nodes.push(attr);
                    }
                    else {
                        attrs.edges.push(attr);
                    }
                }
            });
            console.log(attrs);

            var node_attrs = Object.keys(style[0].style);
            var edge_attrs = Object.keys(style[1].style);

            // set style attribute to null unless highlighted
            for (var i = 0; i < node_attrs.length; i++) {
                if (attrs.nodes.indexOf(node_attrs[i]) === -1) {
                    style[0].style[node_attrs[i]] = null;
                }
            }

            for (var i = 0; i < edge_attrs.length; i++) {
                if (attrs.edges.indexOf(edge_attrs[i]) === -1) {
                    style[1].style[edge_attrs[i]] = null;
                }
            }

            return style;
        }

        function makeRandomNetwork() {
            var nodes = d3.range(0, 100).map(function (d) {
                return {
                    data: {
                        id: d.toString()
                    }
                };
            });
            var edges = d3.range(101, 150).map(function (d) {
                return {
                    data: {
                        id: d.toString(),
                        source: Math.floor(Math.random() * 100).toString(),
                        target: Math.floor(Math.random() * 100).toString()
                    }
                };
            });
            var data = [];
            for (var i = 0; i < nodes.length; i++) {
                data.push(nodes[i]);
            }
            for (var i = 0; i < edges.length; i++) {
                data.push(edges[i]);
            }
            console.log(data);
            return {
                container: document.getElementById('cy'),
                elements: data,
//            style: generateStyle()
                style: editStyle(generateStyle(), whichHighlight())
            };
        }


        function whichHighlight() {
            var items = [];
            d3.selectAll('.rankedcell').each(function (k) {
                var it = d3.select(this);
                var high = it.attr('bgcolor');
                var reg = /row\d+/g;
                console.log(high);
                if (high !== null) {
                    var row = it.attr('class').match(reg);
                    items.push(row[0]);
                }
            });
            return items.getUnique();
        }


    //editStyle(generateStyle(),whichHighlight())

    function getDomain(type, cond) {
        if (type === "node") {
            return cy.nodes(cond).map(function (val) {
                return val.data().value;
            }).getUnique();
        }
        else {
            return cy.edges(cond).map(function (val) {
                return val.data().value;
            }).getUnique();
        }
    }

    function debugo() {

        // highlighted items
        var highlightedCells = [];
        d3.selectAll('[bgcolor="#F3F315"]').each(function (d) {
            var hienc = d3.select(this).attr('class');
            var row = hienc.match(/row\d+/g)[0];
            var col = hienc.match(/col\d+/g)[0];
            highlightedCells.push({encoding: row, dim: col});
        });

        //keep thing in same order as encoding rows so I can do array lookup
        var thing = [
            {encname: 'node color (seq)', func: nodecolor_seq, style: 'background-color', type: 'node', range: colorbrewer.Reds},
            {encname: 'node color (div)', func: nodecolor_div, style: 'background-color', type: 'node', range: colorbrewer.RdBu},
            {encname: 'node color (cat)', func: nodecolor_cat, style: 'background-color', type: 'node', range: colorbrewer.Set2},
            {
                encname: 'node shape (cat)',
                func: nodeshape_cat,
                style: 'shape',
                type: 'node',
//                range: [ ["rectangle"], ["roundrectangle"], ["ellipse"], ["triangle"], ["pentagon"], ["hexagon"], ["heptagon"], ["octagon"], ["star"], ["diamond"], ["vee"], ["rhomboid"] ]
                range: { 1: ["rectangle"],
                         2: ["rectangle", "roundrectangle"],
                         3: ["rectangle", "roundrectangle", "ellipse"],
                         4: ["rectangle", "roundrectangle", "ellipse", "triangle"],
                         5: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon"],
                         6: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon"],
                         7: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon"],
                         8: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon"],
                         9: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star"],
                         10: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star", "diamond"],
                         11: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star", "diamond", "vee"],
                         12: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star", "diamond", "vee", "rhomboid"] }
            },
            {encname: 'node border (quant)', func: nodeborder_quant, style: 'border-width', type: 'node', range: [1, 5, 10]},
            {encname: 'node border (bin)', func: nodeborder_bin, style: 'border-width', type: 'node', range: [1, 5, 10]},
            {encname: 'node border (cat)', func: nodeborder_cat, style: 'border-width', type: 'node', range: [1, 5, 10]},
            {encname: 'edge width (quant)', func: edgewidth_quant, style: 'width', type: 'edge', range: [1, 5, 10]},
            {encname: 'edge width (bin)', func: edgewidth_bin, style: 'width', type: 'edge', range: [1, 5, 10]},
            {encname: 'edge color (seq)', func: edgecolor_seq, style: 'line-color', type: 'edge', range: colorbrewer.Blues},
            {encname: 'edge color (div)', func: edgecolor_div, style: 'line-color', type: 'edge', range: colorbrewer.BuGn},
            {encname: 'edge color (cat)', func: edgecolor_cat, style: 'line-color', type: 'edge', range: colorbrewer.Set3},
            {
                encname: 'edge pattern (cat)',
                func: edgepattern_cat,
                style: 'line-style',
                type: 'edge',
                range: ["solid", "dotted", "dashed"]
            },
            {
                encname: 'edge arrow (cat)',
                func: edgearrow_cat,
                style: 'line-style',
                type: 'edge',
                range: ["solid", "dotted", "dashed"]
            }
        ];

        var colorfuncs = [nodecolor_cat, nodecolor_div, nodecolor_seq,
            edgecolor_cat, edgecolor_div, edgecolor_seq];

        // for each highlight, get the column (dimension) and row (encoding)
//        var dim_task = cy.nodes().map(function(k) { return(k.data().dimension) }).getUnique();

        highlightedCells.forEach(function (rc) {
            var columnNumber = rc.dim.replace('col', '');
            var rowNumber = rc.encoding.replace('row', '');
            var arrayOfDimTask = Object.keys(manifest).map(function (k) {
                return manifest[k];
            });
            var condition = "[dimension=\'" + arrayOfDimTask[columnNumber - 1].name + "\']";
            var ele = thing[rowNumber - 1];
            console.log([condition, ele.encname, ele.func, rowNumber, columnNumber, ele ]);
            var tempdomain = cy.nodes(condition).map(function(n) { return n.data().value; });
            console.log(["domain", tempdomain]);
            var temprange = ele.range[tempdomain.length | 3] || ele.range.slice(0,tempdomain.length);
            console.log(["range", temprange ]);
//            letsee(condition, ele.style, ele.func, temprange);




//            if (ele.type === "node") {
//                cy.nodes(condition).css( ele.style, function(n) {
//                    console.log(['node', ele.encname, ele.func, n.data().value, n.data() ]);
//                    return n.css(ele.style); // this is so it won't complain that cytoscape doesn't take null setter values
////                    return specificfunc(n.data().value);
//                })
//            }

//            else {
//                cy.edges(condition).css( ele.style, function(n) {
//                    console.log(['edge', ele.encname, ele.func, encodingRenderFunctions[ele.encname].func, thing[rowNumber - 1].func, n.data().value, n.data() ]);
//                    return n.css(ele.style); // this is so it won't complain that cytoscape doesn't take null setter values
////                    return specificfunc(n.data().value);
//                })
//            }





        });
    }

//    function letsee(selector, styleoption, infunc, inrange) {
//        var selector = selector;
//        var newstyle = cytoscape.stylesheet()
//                .selector(selector)
//                .style({
//                    styleoption : function( ele ) {
//                        var predomain = cy.nodes(selector).map(function(k){return k.data().value});
//                        var prefunc = infunc(predomain,inrange)
//                        console.log(['heyho', ele.data(), predomain, prefunc, prefunc(ele.data().value)]);
//                        return prefunc(ele.data().value);
//                    }
//                });
//        cy.style(newstyle);
//    }

    var thing = [
        {encname: 'node color (seq)', func: nodecolor_seq, style: 'background-color', type: 'node', range: colorbrewer.Reds},
        {encname: 'node color (div)', func: nodecolor_div, style: 'background-color', type: 'node', range: colorbrewer.RdBu},
        {encname: 'node color (cat)', func: nodecolor_cat, style: 'background-color', type: 'node', range: colorbrewer.Set2},
        {
            encname: 'node shape (cat)',
            func: nodeshape_cat,
            style: 'shape',
            type: 'node',
//                range: [ ["rectangle"], ["roundrectangle"], ["ellipse"], ["triangle"], ["pentagon"], ["hexagon"], ["heptagon"], ["octagon"], ["star"], ["diamond"], ["vee"], ["rhomboid"] ]
            range: { 1: ["rectangle"],
                2: ["rectangle", "roundrectangle"],
                3: ["rectangle", "roundrectangle", "ellipse"],
                4: ["rectangle", "roundrectangle", "ellipse", "triangle"],
                5: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon"],
                6: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon"],
                7: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon"],
                8: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon"],
                9: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star"],
                10: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star", "diamond"],
                11: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star", "diamond", "vee"],
                12: ["rectangle", "roundrectangle", "ellipse", "triangle", "pentagon", "hexagon", "heptagon", "octagon", "star", "diamond", "vee", "rhomboid"] }
        },
        {encname: 'node border (quant)', func: nodeborder_quant, style: 'border-width', type: 'node', range: [1, 5, 10]},
        {encname: 'node border (bin)', func: nodeborder_bin, style: 'border-width', type: 'node', range: [1, 5, 10]},
        {encname: 'node border (cat)', func: nodeborder_cat, style: 'border-width', type: 'node', range: [1, 5, 10]},
        {encname: 'edge width (quant)', func: edgewidth_quant, style: 'width', type: 'edge', range: [1, 5, 10]},
        {encname: 'edge width (bin)', func: edgewidth_bin, style: 'width', type: 'edge', range: [1, 5, 10]},
        {encname: 'edge color (seq)', func: edgecolor_seq, style: 'line-color', type: 'edge', range: colorbrewer.Blues},
        {encname: 'edge color (div)', func: edgecolor_div, style: 'line-color', type: 'edge', range: colorbrewer.BuGn},
        {encname: 'edge color (cat)', func: edgecolor_cat, style: 'line-color', type: 'edge', range: colorbrewer.Set3},
        {
            encname: 'edge pattern (cat)',
            func: edgepattern_cat,
            style: 'line-style',
            type: 'edge',
            range: ["solid", "dotted", "dashed"]
        },
        {
            encname: 'edge arrow (cat)',
            func: edgearrow_cat,
            style: 'line-style',
            type: 'edge',
            range: ["solid", "dotted", "dashed"]
        }
    ];

    function anotherTry(dimension_task,encoding_type) {
//        var selector = '[dimension="p-val"]';
        var items = [];
        var selector = '[dimension=\"'+manifest[dimension_task].name+'\"]';
        console.log(['coord', manifest[dimension_task], encodingRenderFunctions[encoding_type], thing[encodingRenderFunctions[encoding_type].ind].style   ]);
        var thang = {};
        thang[ thing[encodingRenderFunctions[encoding_type].ind].style ] = function( ele ) {
            var predomain = cy.nodes(selector).map(function(k){return k.data().value});
//            var prefunc = d3.scale.ordinal().domain(predomain).range(colorbrewer.Dark2[3]);
            var prerange = function() {
                return thing[encodingRenderFunctions[encoding_type].ind].range[predomain.length | 3] || thing[encodingRenderFunctions[encoding_type].ind].range.slice(0,predomain.length);
            }
            var prefunc = thing[encodingRenderFunctions[encoding_type].ind].func(predomain,prerange());
            console.log(['heyho', ele.data(), predomain, prerange(), prefunc, prefunc(ele.data().value)]);
            return prefunc(ele.data().value);
        };
        console.log(thang);

        thang['shape'] = function() {
            return 'triangle';
        };

        thang['width'] = function() {
            return 400;
        }

        var newstyle = cytoscape.stylesheet()
                .selector(selector)
//                .style({
//                    'background-color' : function( ele ) {
//                        var predomain = cy.nodes(selector).map(function(k){return k.data().value});
//                        var prefunc = d3.scale.ordinal().domain(predomain).range(colorbrewer.Dark2[3]);
//                        console.log(['heyho', ele.data(), predomain, prefunc, prefunc(ele.data().value)]);
//                        return prefunc(ele.data().value);
//                    }
//                })
                .style(thang);
        cy.style(newstyle);
    }

    function makeThang(inputDimension, inputEncodings){
        var selector = '[dimension=\"'+inputDimension+'\"]';
        var sheet = {};
        inputEncodings.sort().forEach(function(e) {
            console.log([selector, e, thing[e].encname]);
            if (thing[e].type === "node") {
                var predomain = cy.nodes(selector).map(function(k){return k.data().value});
                var prerange = function() {
                    return thing[e].range[predomain.length | 3] || thing[e].range.slice(0,predomain.length);
                };
                var prefunc = thing[e].func(predomain,prerange());
                sheet[ thing[e].style ] = function( ele ) {
                    return prefunc(ele.data().value);
                }
            }
        });
        console.log(sheet);
        return cytoscape.stylesheet().selector(selector).style(sheet);
    }



    //This works
//    cy.style(  cytoscape.stylesheet()
//            .selector('[dimension="p-val"]')
//            .style({
//                'background-color': function( ele ) {
//                    var predomain = cy.nodes('[dimension="p-val"]').map(function(k){return k.data().value});
//                    console.log(['heyho', ele.data(), predomain]);
//                    return 'green';
//                },
//                'shape': function( ele ) {
//                    var predomain = cy.nodes('[dimension="p-val"]').map(function(k){return k.data().value});
//                    console.log(['heyho', ele.data(), predomain]);
//                    return 'triangle';
//                }
//            })
//    )

    //This also works
//    cy.style(  cytoscape.stylesheet()
//            .selector('[dimension="p-val"]')
//            .style({
//                'background-color': function( ele ) {
//                    var predomain = cy.nodes('[dimension="p-val"]').map(function(k){return k.data().value});
//                    console.log(['heyho', ele.data(), predomain]);
//                    return 'pink';
//                }
//            })
//            .style({
//                'shape': function( ele ) {
//                    var predomain = cy.nodes('[dimension="p-val"]').map(function(k){return k.data().value});
//                    console.log(['heyho', ele.data(), predomain]);
//                    return 'rectangle';
//                }
//            })
//    )

//    highlightedCells.sort(function(a, b) {return +a.dim.replace('col','') - +b.dim.replace('col','');})




    // Get unique dimension names
//    var uniqueDims = Object.keys(manifest).map(function (k) {
//        return manifest[k].name;
//    }).getUnique()

    // Get indexes of columns of first dimension in array. I need to match these numbers to highlightedcell dim numbers
//    var toMatchtoHC = Object.keys(manifest).map(function (k,i) {
//        if (manifest[k].name === uniqueDims[0]) {
//            return i;
//        }
//    }).filter(function( element ) {
//        return element !== undefined;
//    });

    // Only retrieve manifest columns of matched numbers
//    highlightedCells.map(function(n){ if ( toMatchtoHC.indexOf(+n.dim.replace('col','')-1)!== -1 ) { return n }  }).filter(function( element ) {
//        return element !== undefined;
//    })

    // Use previous step to obtain encoding row numbers (for thing lookup)
//    var encToUse = highlightedCells.map(function(n){ if ( toMatchtoHC.indexOf(+n.dim.replace('col','')-1)!== -1 ) { return n; }  }).filter(function( element ) {
//        return element !== undefined;
//    }).map(function(n) { return +n.encoding.replace('row','')-1; })




</script>
</html>


